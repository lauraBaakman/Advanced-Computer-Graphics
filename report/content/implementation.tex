%!TEX root = ../main.tex

\section{Implementation}
\label{s:implementation}

	\begin{figure}
		\centering
		\begin{subfigure}[b]{0.4\columnwidth}
			\centering
			\includegraphics[width=\textwidth]{content/img/implementation/pipeline_oldOpenGL.png}
			\caption{OpenGL version 1.3}
			\label{fig:implementation:pipeline:old}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\columnwidth}
			\centering
			\includegraphics[width=\textwidth]{content/img/implementation/pipeline_newOpenGL.png}
			\caption{OpenGL version 4.1}
			\label{fig:implementation:pipeline:new}
		\end{subfigure}	
		\caption{A schematic overview of the programmable parts of the \subref{fig:implementation:pipeline:old} 1.3 and \subref{fig:implementation:pipeline:new} 4.1 OpenGL graphics pipelines. Each rounded rectangle represents one programmable shader.}
		\label{fig:implementation:pipeline}
	\end{figure}

	A schematic overview of both the OpenGL pipeline at the time of the publication of the paper and the current pipeline is presented in \cref{fig:implementation:pipeline}. These diagrams show that since \citeyear{vlachos2001curved} three new shaders have been introduced into the pipeline, namely the tessellation control (TC), tessellation evaluation (TES) and the geometry shader. 

	Since only the tessellation shaders are relevant for point-normal triangles we discuss those in more detail in \crefs{ss:implementation:pipeline}. \Crefs{ss:implementation:tcs} through \ref{ss:implementation:tes} present our implementation of point-normal triangles per discussed tessellation stage. 

\subsection{Tessellation in OpenGL}
\label{ss:implementation:pipeline}

	% Tesselation:
	A schematic overview of tessellation in OpenGL is presented in \Cref{fig:implementation:tessellationPipeline}.
	% Tesselation control
	The tessellation control shader is invoked once for each vertex in the input primitive, see \cref{fig:method:input_primitive} for an illustration of our input primitives.
	% What does it do
	One of the functions of the tessellation control shader is to set the inner and the outer tessellation levels. Furthermore, the TCS can compute additional information about the vertices in the input patch. 
	% Output:
	As can been seen in \cref{fig:implementation:tessellationPipeline} the TCS passes additional information about that patch along to the tessellation evaluation shader (TES) via the output patch. The inner and outer tessellation levels are sent to the tessellation primitive generator (TPG) \cite{wolff2013opengl}.

	The TPG generates a number of new primitives based on the tessellation levels. How these primitives are generated depends on the selected edge tessellation spacing algorithm. Equal spacing results in evenly divided edges, whereas fractional spacing allows for two shorter edges in the subdivision, which ensures a more stable interpolation under changing tessellation levels \cite{wolff2013opengl,openGL41Core}. In the case of triangles, the barycentric coordinates of the vertices of the newly generated primitives are passed to the TES, as shown in \cref{fig:implementation:tessellationPipeline}.

	% Tesselation evaluation
	% Invoked for
	The tessellation evaluation shader is executed for each vertex that is generated by the TPG. 
	% Input:
	It receives the coordinates of this vertex in parameter space and the output of the TCS, as is illustrated in \cref{fig:implementation:tessellationPipeline}. 
	% What does it do
	Based on this information the tessellation evaluation shader computes the position of the current vertex, \cite{wolff2013opengl}. 
	% Output:	
	The computed data are passed to the next shader in the pipeline, either the geometry shader or the fragment shader, see \cref{fig:implementation:pipeline:new}.

	\begin{figure*}
		\centering
		\includegraphics[width=\textwidth, height = 0.25\textheight, keepaspectratio]{content/img/implementation/tessellationPipeline-01.png}
		\caption{An overview of the tessellation part of the OpenGL version 4.1 rendering pipeline as applied to point normal triangles. An input patch, a triangle with normals, is presented to the tessellation control shader (TCS). The tessellation primitive generator (TPG) tessellates the triangle and outputs the barycentric coordinates of the newly generated triangle to the tessellation evaluation shader (TES). Apart from these coordinates the TES also receives the control nets from the TCS. Illustration adapted from \textcite{wolff2013opengl}.}
		\label{fig:implementation:tessellationPipeline}
	\end{figure*}

\subsection{Tessellation Control Shader}
\label{ss:implementation:tcs}
	% Input
	The TCS receives both the positions of the vertices and the normals of the input patch, i.e. the input primitive shown in \cref{fig:method:input_primitive}.
	%Computation:
		% Geometry
		Based on its input this shader computes the control net that defines the geometry of the point-normal triangle according to \crefe{eq:method:vertex_coefficients} through \ref{eq:method:center_coefficient}.
		% Fake normals
		If `fake' normals are used, their control net is computed as described in \crefs{sss:method:normals:fakeNormals}.
		% Real normals
		The `real' normals need no computations in the tessellation control shader, since they are based on the geometry of the point-normal triangle.

		We parallelize the computations of the $x$, $y$ and $z$ component of the vertices of the output patch by using the \texttt{invocation\_ID} to select which component of the output patch to compute. For example, if the TCS is invoked for the second vertex of an input patch, i.e., \texttt{invocation\_ID} = 1, we compute the $y$ component of all the vertices of the output patch. This only works since the number of vertices of the input patch is equal to the dimensionality of the positions of the vertices of the output patch.

		There are two alternative ways to compute the output patch. One method is by only computing the output data for e.g. the first vertex. This ensures that no computations are performed twice, however it also means that a lot of threads are waiting for the threads that happened to receive the first vertex of an input patch to finish. Another downside of this method is that since you cannot guarantee that all executions in a warp have the same \texttt{invocation\_ID}, the branching impacts the performance negatively \cite{fung2007dynamic}.
		%
		Alternatively, one could compute all vertices of the output patch, independent of the \texttt{invocation\_ID}. This results in a lot of unnecessary computations, but removes the branching penalty that occurs when one only computes the control net if the \texttt{invocation\_ID} has a specific value. 

		Neither of these methods are more efficient than the one we used. A downside of our method is that one has to construct the vectors that represent the vertices of the control net in the tessellation evaluation shader. 

		Other than computing the control nets, this shader also sets the inner and outer tessellation level for the tessellation primitive generator. 
		%Output
		The control nets are output to the tessellation evaluation shader whereas the tessellation levels are sent to the tessellation primitive generator. 

		Although the next shader, the tessellation primitive generator, is not programmable, we can control its output via some parameters that are set in the TES, most notably the tessellation levels and the edge tessellation spacing algorithm. We have left the selection of the tessellation levels to the user. This means that the tessellation levels of a rendered object can be changed on the fly, consequently it is important that the transition between different tessellation levels is smooth. We have thus opted to set the tessellation algorithm to fractional odd spacing, which gives a smooth transition \cite{cozzi2012opengl}. 

\begin{figure}
	\plaatje{Eventueel: Overtrekken in illustrator, laat rare groene lijnen in tweede plaatje weg. Gebruik geen groen maar blauw en oranje. Maak plaatje met uiteindelijke tessellations.}
	\centering
	\begin{subfigure}[b]{0.18\columnwidth}
		\centering
		\includegraphics[width=\textwidth]{content/img/implementation/tessellation_input.png}
		\caption{Input}
		\label{fig:implementation:step:input}
	\end{subfigure}
	\begin{subfigure}[b]{0.18\columnwidth}
		\centering
		\includegraphics[width=\textwidth]{content/img/implementation/tessellation_1.png}
		\caption{Step \ref{it:implementation:1}}
		\label{fig:implementation:step:1}
	\end{subfigure}	
	\begin{subfigure}[b]{0.18\columnwidth}
		\centering
		\includegraphics[width=\textwidth]{content/img/implementation/tessellation_2.png}
		\caption{Step \ref{it:implementation:2}}
		\label{fig:implementation:step:2}
	\end{subfigure}		
	\begin{subfigure}[b]{0.18\columnwidth}
		\centering
		\includegraphics[width=\textwidth]{content/img/implementation/tessellation_3.png}
		\caption{Step \ref{it:implementation:3}}
		\label{fig:implementation:step:3}
	\end{subfigure}		
	\begin{subfigure}[b]{0.18\columnwidth}
		\centering
		\includegraphics[width=\textwidth]{content/img/implementation/tessellation_4.png}
		\caption{Step \ref{it:implementation:4}}
		\label{fig:implementation:step:4}
	\end{subfigure}		
	\caption{Generation of a primitive for the TES  from  \ref{fig:implementation:step:input} an input primitive using the TPG from OpenGL. Illustration taken from \cite{cozzi2012opengl}.}
	\label{fig:implementation:step}
\end{figure}

\subsection{Tessellation Primitive Generator}
\label{ss:implementation:tpg}
	The TPG tessellates an input triangle, see \cref{fig:implementation:step:input}, according to these steps \cite{cozzi2012opengl}:
		\begin{enumerate}[label=(\roman*)]
			\item \label{it:implementation:1} The patch is divided into the same number of concentric triangles as the inner tessellation level, see \cref{fig:implementation:step:1}.
			\item \label{it:implementation:2} The spaces between the concentric triangles, except the outer triangle, are subdivided intro triangles, see \cref{fig:implementation:step:2}.
			\item \label{it:implementation:3} The outer edges of the triangles are decomposed into smaller edges according to the outer tessellation level, see \cref{fig:implementation:step:3}.
			\item \label{it:implementation:4} The outer ring of triangles is subdivided into triangles by connecting the vertices from the inner triangles with those of the other triangles, see \cref{fig:implementation:step:4}.
		\end{enumerate}
	A triangle that is tessellated with fractional spacing, and an inner and outer tessellation level of $4.0$, is presented in \cref{fig:implementation:tessellatedTriangle}. It should be noted that the resulting tessellation is different than the subdivision of triangles proposed by \citeauthor{vlachos2001curved}. 

	\begin{figure}
		\centering
		\includegraphics[width=0.6\columnwidth]{content/img/implementation/tessellatedTriangle.png}
		\caption{A single triangle tessellated with both outer and inner tessellation level set to 4.0, and edge tessellation spacing set to \texttt{fractional\_odd\_spacing}.}
		\label{fig:implementation:tessellatedTriangle}
	\end{figure}

\subsection{Tessellation Evaluation Shader}
\label{ss:implementation:tes}
	% Input
	Due to our parallelization the first step in the TES is to extract the control points from the input. 
	% Geometry
	Once we have the control nets, we determine the positions of the vertices of the flat triangles that will form the final patch, according to \crefe{eq:method:cubic_bezier_patch}. 
	% Normals
	We compute the normals according to either \crefe{eq:method:quadratic_normal_patch} or \crefe{eq:method:normal:realNormal}.