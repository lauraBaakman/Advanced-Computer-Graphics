%!TEX root = ../main.tex

\section{Implementation}
\label{s:implementation}
\rick{Nalezen:}

\begin{figure}
	\plaatje{Pas de kleuren aan, pas het font aan, maak de pipelines verticaal, laat de twee teseelations shaders zien, geef alle blokjes dezelfde stijl, met tikz maken?}
	\centering
	\begin{subfigure}{\columnwidth}
		\centering
		\includegraphics[width=\columnwidth]{content/img/implementation/pipeLineOld.png}
		\caption{The graphics pipeline of OpenGL version 1.3 (2001).}
		\label{fig:implementation:pipeline:old}
	\end{subfigure}
	\begin{subfigure}{\columnwidth}
		\centering
		\includegraphics[width=\columnwidth]{content/img/implementation/pipeLineNew.png}
		\caption{The graphics pipeline of OpenGL version 4.1 (2010).}
		\label{fig:implementation:pipeline:new}
	\end{subfigure}	
	\caption{A schematic overview of the programmable parts of the \subref{fig:implementation:pipeline:old} 1.3 and \subref{fig:implementation:pipeline:new} 4.1 OpenGL graphics pipelines. Each rounded rectangle represents one programmable shader.}
	\label{fig:implementation:pipeline}
\end{figure}

A schematic overview of both the OpenGL pipeline at the time of the publication of the paper and the introduces PN-triangles and the current pipeline are presented in \cref{fig:implementation:pipeline}. These images show that since \citeyear{vlachos2001curved} three new shaders have been introduced into the pipeline, namely the tessellation control, tessellation evaluation and the geometry shader. 

Since only the tessellation shaders are relevant for point-normal triangles we discuss those in more detail in section \ref{ss:implementation:pipeline}. Section \ref{ss:implementation:tcs} through section \ref{ss:implementation:tes} present our implementation of point-normal triangles per discussed tessellation stage. 

\subsection{Tessellation in OpenGL}
\label{ss:implementation:pipeline}

	% Tesselation:
	A schematic overview of tessellation in OpenGL is presented \Cref{fig:implementation:tessellationPipeline}.
	% Tesselation control
	% Invoked for
	The tessellation control shader (TCS) is invoked once for each vertex in the output patch, a triangle in our case. 
	% What does it do
	The primary function of the tessellation control shader is the setting of both the inner and the outer tessellation levels. Additionally the TCS can compute additional information about the vertices in the input patch. 
	% Output:
	As can been seen in \cref{fig:implementation:tessellationPipeline} the TCS passes additional information about that patch along to the tessellation evaluation shader (TES) via the output patch. The tessellation levels are sent to the tessellation primitive generator (TPG) \cite{wolff2013opengl}.

	The TPG generates a number of new primitives based on the tessellation levels. How these primitives are generated depends on the selected edge tessellation spacing. Equal spacing results in evenly divided edges, whereas fractional spacing allows for two shorter edges in the subdivision for more stable interpolation under changing tessellation levels \cite{wolff2013opengl,openGL41Core}.

	% Tesselation evaluation
	% Invoked for
	The tessellation evaluation shader (TES) is executed for each vertex that is generated by the TPG. 
	% Input:
	It receives the coordinates of this vertex in parameter space and the output of the TCS, as is illustrated in \cref{fig:implementation:tessellationPipeline}. 
	% What does it do
	Based on this information it computes the position of the current vertex. 
	% Output:
	This shader is passed to the next shader in the pipeline, either the geometry shader or the fragment shader, see \cref{fig:implementation:pipeline:new} \cite{wolff2013opengl}.

	\begin{figure}
		\centering
		\includegraphics[width=\columnwidth]{content/img/implementation/tesselationPipeline.png}
		\caption{An overview of the tessellation part of the OpenGL render pipeline. Note that in the case of point-normal triangles the input patches, generated primitives and output patches are triangles, not quads. Illustration taken form \textcite{wolff2013opengl}.}
		\label{fig:implementation:tessellationPipeline}
	\end{figure}

\subsection{Tesselation Control Shader}
\label{ss:implementation:tcs}
	% Input
	The TCS receives both the normals and the positions of the vertices of the input patch, in our case a single triangle. 
	%Computation:
		% Geometry
		Using these it computes the cubic BÃ©zier patch that defines the geometry of the point-normal triangle according to equation \eqref{eq:method:cubic_bezier_patch}.
		% Fake normals
		If `fake' normals are used their control net is computed as well. 
		% Real normals
		The `real' normals need no computations in the tessellation control shader.

		We parallelize the computations of the $x$, $y$ and $z$ component of the vertices of the output patch by using the \texttt{invocation\_ID} to select which component of the output patch to compute. For example if the TCS is invoked for the second vertex of an input patch, i.e. \texttt{invocation\_ID} = 2, we compute the $y$ component of all the vertices of the output patch. This only works since the number of vertices of the input patch is equal to the dimensionality of the positions of the vertices of the output patch.

		There are two alternative ways to compute the output patch. One method is by only computing the output data for e.g. the first vertex. This ensures that no computations are performed twice, however it also means that a lot of threads are waiting for the threads that happened to received the first vertex of a input patch to finish.  
		%
		Alternatively one could always compute all vertices of the output patch, independent of the \texttt{invocation\_ID}. This results in a lot of unnecessary computations, but removes the branching required to only compute the control net if the \texttt{invocation\_ID} has a specific value. Neither of these methods are more efficient than the one we used. A downside of our method is that one has to construct the vectors that represent the vertices of the control net in the tessellation evaluation shader. 

	%Output

	% To speed up the computation of the control net(s) we make use of the fact that the dimensionality of the positions is the same as the number of vertices of the input patch. Based on the \texttt{invocation\_ID}, for which of the three dimensions we compute the component of the output patch, e.g. if the \texttt{invocation\_ID} is 0 we compute the $y$ component of the data in the output patch for all vertices of that patch. This allows up to parallelize the computations of the control net. Although we perform some computations more often than necessary, e.g. $w(ij)$ and $v(ij)$ \todo{as defined in...}, this is faster than computing all three dimension of the output patch for each invocation of a patch or only performing the computations for one specific invocation of the patch. 


\subsection{Tessellation Primitive Generator}
\label{ss:implementation:tpg}
	% Geometry

	% Fake normals

	% Real normals

\subsection{Tessellation Evaluation Shader}
\label{ss:implementation:tes}
	% Geometry

	% Fake normals

	% Real normals